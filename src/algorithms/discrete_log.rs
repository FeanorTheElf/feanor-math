
use crate::algorithms::eea::inv_crt;
use crate::algorithms::int_bisect::bisect_floor;
use crate::algorithms::int_bisect::find_root_floor;
use crate::algorithms::int_bisect::root_floor;
use crate::algorithms::int_factor::factor;
use crate::algorithms::linsolve::LinSolveRingStore;
use crate::algorithms::lll;
use crate::algorithms::lll::exact::lll;
use crate::algorithms::matmul::MatmulAlgorithm;
use crate::algorithms::matmul::STANDARD_MATMUL;
use crate::algorithms::sqr_mul::generic_abs_square_and_multiply;
use crate::assert_matrix_eq;
use crate::divisibility::DivisibilityRingStore;
use crate::field::Field;
use crate::field::FieldStore;
use crate::homomorphism::Homomorphism;
use crate::integer::int_cast;
use crate::integer::BigIntRing;
use crate::matrix::AsPointerToSlice;
use crate::matrix::OwnedMatrix;
use crate::matrix::Submatrix;
use crate::matrix::SubmatrixMut;
use crate::matrix::TransposableSubmatrix;
use crate::matrix::TransposableSubmatrixMut;
use crate::primitive_int::StaticRing;
use crate::ring::*;
use crate::algorithms;
use crate::rings::finite::FiniteRingStore;
use crate::rings::rational::RationalField;
use crate::rings::zn::ZnRing;
use crate::ordered::OrderedRingStore;
use crate::seq::CloneValue;
use crate::seq::VectorFn;
use crate::seq::VectorView;
use crate::wrapper::RingElementWrapper;
use crate::DEFAULT_PROBABILISTIC_REPETITIONS;

use std::alloc::Global;
use std::array::from_fn;
use std::convert::identity;
use std::hash::Hash;
use std::collections::HashMap;
use std::hash::Hasher;
use std::mem::replace;
use std::slice::from_ref;

const ZZ: StaticRing<i64> = StaticRing::<i64>::RING;

pub trait DlogCapableGroup {
    type Element;

    fn clone_el(&self, x: &Self::Element) -> Self::Element;
    fn eq_el(&self, lhs: &Self::Element, rhs: &Self::Element) -> bool;
    fn op(&self, lhs: Self::Element, rhs: &Self::Element) -> Self::Element;
    fn inv(&self, x: &Self::Element) -> Self::Element;
    fn identity(&self) -> Self::Element;
    fn hash<H: Hasher>(&self, x: &Self::Element, hasher: &mut H);

    fn pow(&self, x: &Self::Element, e: i64) -> Self::Element {
        debug_assert!(e >= 0);
        // even if the monoid is in general not commutative, it is here since we actually only work in the 
        // cyclic monoid generated by `base`
        generic_abs_square_and_multiply(
            self.clone_el(x), 
            &e, 
            ZZ, 
            |a| self.op(self.clone_el(&a), &a), 
            |a, b| self.op(b, &a), 
            self.identity()
        )
    }

    fn is_identity(&self, x: &Self::Element) -> bool {
        self.eq_el(x, &self.identity())
    }
}

pub struct AddGroup<R: RingStore>(pub R);

pub struct ProdGroup<G: DlogCapableGroup, const N: usize>(G);

impl<R: RingStore> DlogCapableGroup for AddGroup<R>
    where R::Type: HashableElRing
{
    type Element = El<R>;

    fn clone_el(&self, x: &Self::Element) -> Self::Element { self.0.clone_el(x) }
    fn eq_el(&self, lhs: &Self::Element, rhs: &Self::Element) -> bool { self.0.eq_el(lhs, rhs) }
    fn op(&self, lhs: Self::Element, rhs: &Self::Element) -> Self::Element { self.0.add_ref_snd(lhs, rhs)}
    fn inv(&self, x: &Self::Element) -> Self::Element { self.0.negate(self.0.clone_el(x)) }
    fn identity(&self) -> Self::Element { self.0.zero() }
    fn hash<H: Hasher>(&self, x: &Self::Element, hasher: &mut H) { self.0.hash(x, hasher) }
}

impl<G: DlogCapableGroup, const N: usize> DlogCapableGroup for ProdGroup<G, N> {
    type Element = [G::Element; N];

    fn clone_el(&self, x: &Self::Element) -> Self::Element { from_fn(|i| self.0.clone_el(&x[i])) }
    fn eq_el(&self, lhs: &Self::Element, rhs: &Self::Element) -> bool { (0..N).all(|i| self.0.eq_el(&lhs[i], &rhs[i])) }
    fn inv(&self, x: &Self::Element) -> Self::Element { from_fn(|i| self.0.inv(&x[i])) }
    fn identity(&self) -> Self::Element { from_fn(|_| self.0.identity()) }
    fn hash<H: Hasher>(&self, x: &Self::Element, hasher: &mut H) { x.into_iter().for_each(|x| self.0.hash(x, hasher)) }
    
    fn op(&self, lhs: Self::Element, rhs: &Self::Element) -> Self::Element { 
        let mut it = lhs.into_iter().zip(rhs.into_iter()).map(|(l, r)| self.0.op(l, r));
        return from_fn(|_| it.next().unwrap());
    }
}

struct HashableGroupEl<'a, G: DlogCapableGroup> {
    group: &'a G,
    el: G::Element
}

impl<'a, G: DlogCapableGroup> HashableGroupEl<'a, G> {
    fn new(group: &'a G, el: G::Element) -> Self {
        Self { group, el }
    }
}

impl<'a, G: DlogCapableGroup> PartialEq for HashableGroupEl<'a, G> {
    fn eq(&self, other: &Self) -> bool {
        self.group.eq_el(&self.el, &other.el)
    }
}

impl<'a, G: DlogCapableGroup> Eq for HashableGroupEl<'a, G> {}

impl<'a, G: DlogCapableGroup> Hash for HashableGroupEl<'a, G> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.group.hash(&self.el, state)
    }
}

///
/// Computes the a vector `k` with entries `1 <= k[i] <= dlog_bounds[i]` such that
/// `generators^k = value` (`generators` is a list of elements of an abelian group).
/// 
/// If there is no such vector, then `None` is returned. If there are multiple such
/// vectors, any one of them is returned. In the 1d-case, it is guaranteed that this
/// is the smallest one, but in the multidimensional case, no such guarantee can be made
/// (in particular, the vector in general won't be the shortest one w.r.t. any natural
/// ordering like lex or degrevlex).
/// 
/// Note: The vector `k` is required to have positive entries. In particular, this
/// function won't return the zero vector if the given element is the identity.
/// This can have unexpected consequences, like
/// ```
/// # use feanor_math::algorithms::discrete_log;
/// assert_eq!(Some(vec![1]), baby_giant_step(0, &[0], &[1000], |a, b| a + b, 0));
/// ```
/// 
/// # Implementation notes
/// 
/// The complexity of the algorithm is `O(sqrt(prod_i dlog_bounds[i]))`. 
/// Thus, when possible, `order_bound[i]` should be the order of `generators[i]`
/// in the group.
/// 
/// Why do we need a group? Because we search for collisions `ab = ac`, and assume
/// that this implies `b = c`. So actually,  a cancelable abelian monoid would be sufficient...
/// 
/// Why don't we use Pollard's rhos? Because Pollard's rho cannot deterministically
/// detect the case that `value` is not in the subgroup generated by `generators`.
/// It can do so with high probability, but only if the used hash function satisfies
/// certain properties. With BSGS, the correctness does not depend on the used hash
/// function (although performance does, of course).
/// 
/// # Example
/// 
/// ```rust
/// # use feanor_math::ring::*;
/// # use feanor_math::homomorphism::*;
/// # use feanor_math::rings::zn::*;
/// # use feanor_math::rings::zn::zn_64::*;
/// # use feanor_math::wrapper::*;
/// # use feanor_math::algorithms::discrete_log::*;
/// let ring = Zn::new(17);
/// let x = RingElementWrapper::new(&ring, ring.int_hom().map(9));
/// let one = RingElementWrapper::new(&ring, ring.one());
/// assert_eq!(Some((0, Some(8))), baby_giant_step(one.clone(), &x, 1000, |a, b| a * b, one));
/// ```
/// 
#[stability::unstable(feature = "enable")]
pub fn baby_giant_step<G>(group: &G, value: G::Element, generators: &[G::Element], dlog_bounds: &[El<BigIntRing>]) -> Option<Vec<i64>> 
    where G: DlogCapableGroup
{
    let n = generators.len();
    assert_eq!(n, dlog_bounds.len());
    if generators.len() == 0 {
        if group.is_identity(&value) {
            return Some(Vec::new());
        } else {
            return None;
        }
    }
    let ns = dlog_bounds.iter().map(|n| int_cast(root_floor(BigIntRing::RING, n.clone(), 2), ZZ, BigIntRing::RING) + 1).collect::<Vec<_>>();
    let count = int_cast(BigIntRing::RING.prod(ns.iter().map(|n| int_cast(*n, BigIntRing::RING, ZZ))), ZZ, BigIntRing::RING);
    let mut baby_step_table: HashMap<HashableGroupEl<_>, i64> = HashMap::with_capacity(count as usize);
    
    // fill baby step table
    {
        let mut current_els = (0..n).map(|_| group.clone_el(&value)).collect::<Vec<_>>();
        let mut current_idxs = (0..n).map(|_| 0).collect::<Vec<_>>();
        for idx in 0..count {
            _ = baby_step_table.insert(HashableGroupEl::new(group, group.clone_el(&current_els[n - 1])), idx);

            let mut i = n - 1;
            while current_idxs[i] == ns[i] - 1 {
                if i == 0 {
                    assert!(idx + 1 == count);
                    break;
                }
                current_idxs[i] = 0;
                i -= 1;
            }
            current_idxs[i] += 1;
            current_els[i] = group.op(replace(&mut current_els[i], group.identity()), &generators[i]);
            for j in (i + 1)..n {
                current_els[j] = group.clone_el(&current_els[i]);
            }
        }
    }

    let giant_steps = generators.iter().zip(ns.iter()).map(|(g, n)| group.pow(g, *n)).collect::<Vec<_>>();
    // iterate through giant steps
    {
        let start_el = giant_steps.iter().fold(group.identity(), |x, y| group.op(x, y));
        let mut current_els = (0..n).map(|_| group.clone_el(&start_el)).collect::<Vec<_>>();
        let mut current_idxs = (0..n).map(|_| 1).collect::<Vec<_>>();
        for idx in 0..count {
            if let Some(bs_idx) = baby_step_table.get(&HashableGroupEl::new(group, group.clone_el(&current_els[n - 1]))) {
                let mut bs_idx = *bs_idx;
                let mut result = current_idxs.clone();
                for j in (0..n).rev() {
                    let bs_idxs_j = bs_idx % ns[j];
                    bs_idx = bs_idx / ns[j];
                    result[j] = result[j] * ns[j] - bs_idxs_j;
                }
                if (0..dlog_bounds.len()).all(|j| BigIntRing::RING.is_leq(&int_cast(result[j], BigIntRing::RING, ZZ), &dlog_bounds[j])) {
                    debug_assert_eq!(n, result.len());
                    return Some(result);
                }
            }

            let mut i = n - 1;
            while current_idxs[i] == ns[i] {
                if i == 0 {
                    assert!(idx + 1 == count);
                    break;
                }
                current_idxs[i] = 1;
                i -= 1;
            }
            current_idxs[i] += 1;
            current_els[i] = group.op(replace(&mut current_els[i], group.identity()), &giant_steps[i]);
            for j in (i + 1)..n {
                current_els[j] = group.clone_el(&current_els[i]);
            }
        }
    }

    return None;
}

///
/// Takes a matrix whose rows form a basis of the relation lattice w.r.t. group
/// elements `g1, ..., gn` and computes a matrix whose rows form a basis of the relation
/// lattice of `p g1, ..., p gn`.
/// 
fn relation_lattice_basis_downscale_p<V>(basis: Submatrix<V, i64>, p: i64) -> OwnedMatrix<i64>
    where V: AsPointerToSlice<i64>
{
    let n = basis.row_count();
    assert_eq!(n, basis.col_count());
    let QQ = RationalField::new(BigIntRing::RING);
    let ZZ_to_QQ = QQ.inclusion().compose(QQ.base_ring().can_hom(&ZZ).unwrap());
    let as_ZZ = |x| int_cast(BigIntRing::RING.checked_div(QQ.num(x), QQ.den(x)).unwrap(), ZZ, BigIntRing::RING);

    let mut dual_basis = OwnedMatrix::identity(n, 2 * n, &QQ);
    let mut Binv = dual_basis.data_mut().submatrix(0..n, n..(2 * n));
    let mut rhs = OwnedMatrix::identity(n, n, &QQ);
    QQ.solve_right(
        OwnedMatrix::from_fn(n, n, |i, j| ZZ_to_QQ.map_ref(basis.at(i, j))).data_mut(), 
        rhs.data_mut(),
        Binv.reborrow()
    ).assert_solved();
    Binv.reborrow().row_iter().flat_map(|row| row.iter_mut()).for_each(|x| ZZ_to_QQ.mul_assign_map(x, p));

    let mut identity = OwnedMatrix::identity(n, n, &QQ);
    lll(
        &QQ, 
        identity.data(), 
        dual_basis.data_mut(), 
        &QQ.div(&ZZ_to_QQ.map(9), &ZZ_to_QQ.map(10)),
        Global, 
        false
    );

    let mut result = rhs;
    QQ.solve_right(
        dual_basis.data_mut().submatrix(0..n, n..(2 * n)),
        identity.data_mut(),
        result.data_mut()
    ).assert_solved();

    return OwnedMatrix::from_fn(n, n, |i, j| as_ZZ(result.at(i, j)));
}

///
/// Computes the discrete logarithms of each given element w.r.t. the given generators.
/// 
/// In addition, this function requires a basis of the relation lattice of the generators.
/// 
/// # Algorithm
/// 
/// Since we are working over a local ring with maximal ideal `p`, it suffices to find the smallest
/// `k` such that `p^k g'` is contained in the module generated by the previous generators. Then this
/// relation `p^k g' = sum_i ai gi` will complete the relation lattice basis, since any other relation
/// `p^k g = sum_i ai' gi` then differs from the first one by the relation `sum_i (ai' - ai) gi = 0`, which
/// is a relation of the first `n` generators, and thus already generated by the basis.
/// 
/// Hence, the question is how to compute a dlog of `p^k g'` w.r.t. `g1, ..., gn`. For this, we use
/// the exact sequence
/// ```text
///   0  ->  H  ->  G  ->  G/H  ->  0
/// ```
/// where `H = { x in G | px = 0 }` is the `p`-torsion subgroup. Note that the power-of-`p` map
/// gives an isomorphism `G/H -> pG`, which allows us to recursively solve dlog in `G/H`. Hence, we want
/// to solve dlog in `H`, which we can do using the baby-giant step method - if we can find a generating
/// set of `H`. We find it using the already provided basis of the relation modulo of the generators.
/// 
/// More concretely, if `B` is a basis of the relation lattice of `g1, ..., gn`, then `H n <g1, ..., gn>`
/// contains exactly the elements `sum_i x_i g_i` for which `px in BZ^n`. These are exactly the `x` in
/// `(B/p Z^n) n Z^n`. This lattice is equal to `(pB^-T Z^n + Z^n)*`, which we can compute using LLL.
/// 
fn dlogs_from_relation_lattice_basis<G, V>(group: &G, p: i64, e: usize, generators: &[G::Element], basis: Submatrix<V, i64>, elements: &[G::Element]) -> Vec<Option<Vec<i64>>>
    where G: DlogCapableGroup,
        V: AsPointerToSlice<i64>
{
    let n = generators.len();
    assert_eq!(n, basis.row_count());
    assert_eq!(n, basis.col_count());
    debug_assert!(generators.iter().all(|g| group.is_identity(&group.pow(g, ZZ.pow(p, e)))));
    
    if n == 0 || e == 0 {
        return elements.iter().map(|el| if group.is_identity(el) {
            Some((0..n).map(|_| 0).collect())
        } else {
            None
        }).collect();
    }

    let pg_relation_lattice_basis = relation_lattice_basis_downscale_p(basis, p);
    let G_mod_H_dlogs = dlogs_from_relation_lattice_basis(
        group,
        p,
        e - 1,
        &generators.iter().map(|g| group.pow(g, p)).collect::<Vec<_>>(),
        pg_relation_lattice_basis.data(),
        &elements.iter().map(|el| group.pow(el, p)).collect::<Vec<_>>()
    );
    debug_assert!(G_mod_H_dlogs.iter().all(|G_mod_H_dlog| G_mod_H_dlog.is_none() || G_mod_H_dlog.as_ref().unwrap().len() == n));

    // delta is now in H, i.e. is a p-torsion element
    let deltas = elements.iter().zip(G_mod_H_dlogs.iter()).map(|(el, G_mod_H_dlog)| 
        G_mod_H_dlog.as_ref().map(|G_mod_H_dlog| {
            (0..n).fold(group.clone_el(el), |current, i| group.op(current,
                &group.pow(&generators[i], ZZ.pow(p, e) - (G_mod_H_dlog[i] % ZZ.pow(p, e)))
            ))
        })
    ).collect::<Vec<_>>();
    debug_assert!(deltas.iter().all(|delta| delta.is_none() || group.is_identity(&group.pow(delta.as_ref().unwrap(), p))));

    let H_generators = pg_relation_lattice_basis.data().row_iter().map(|row| 
        (0..n).fold(group.identity(), |current, i| group.op(current, &
            group.pow(&generators[i], (row[i] % ZZ.pow(p, e)) + ZZ.pow(p, e))
        ))
    ).collect::<Vec<_>>();
    debug_assert!(H_generators.iter().all(|g| group.is_identity(&group.pow(g, p))));

    let H_dlog_wrt_H_gens = deltas.into_iter().map(|delta| delta.and_then(|delta|
        baby_giant_step(group, delta, &H_generators, &(0..n).map(|_| int_cast(p, BigIntRing::RING, ZZ)).collect::<Vec<_>>())
    ));
    let H_dlog = H_dlog_wrt_H_gens.map(|dlog| dlog.map(|dlog| {
        let mut result = (0..n).map(|_| 0).collect::<Vec<_>>();
        STANDARD_MATMUL.matmul(
            TransposableSubmatrix::from(Submatrix::from_1d(&dlog, 1, n)),
            TransposableSubmatrix::from(pg_relation_lattice_basis.data()),
            TransposableSubmatrixMut::from(SubmatrixMut::from_1d(&mut result, 1, n)),
            ZZ
        );
        return result;
    }));

    return G_mod_H_dlogs.into_iter().zip(H_dlog).zip(elements.iter()).map(|((x, y), el)| 
        x.and_then(|x| y.map(|y| {
            unsafe { debugit::debugit!("el", el) }
            unsafe { debugit::debugit!("gens", generators) }
            unsafe { debugit::debugit!("x", x) }
            unsafe { debugit::debugit!("y", y) }
            let result = x.into_iter().zip(y.into_iter()).map(|(x, y)| x + y).collect::<Vec<i64>>();
            unsafe { debugit::debugit!("res", result) }
            debug_assert!(group.eq_el(el, &(0..n).fold(group.identity(), |current, i| group.op(current, &group.pow(&generators[i], ZZ.pow(p, e) + result[i])))));
            return result;
        }))
    ).collect();
}

///
/// Computes a matrix whose rows form a basis of the relation lattice of the
/// given elements in an abelian group.
/// 
/// In more detail, the set of vector `{ x in Z^n | sum_i xi gi }` is a lattice.
/// 
pub fn compute_relation_lattice_basis<G>(group: &G, p: i64, e: usize, elements: &[G::Element]) -> OwnedMatrix<i64>
    where G: DlogCapableGroup
{
    debug_assert!(elements.iter().all(|g| group.is_identity(&group.pow(g, ZZ.pow(p, e)))));
    let n = elements.len();
    let mut result = OwnedMatrix::zero(n, n, ZZ);

    for i in 0..n {
        let dlogs = dlogs_from_relation_lattice_basis(
            group, 
            p, 
            e, 
            &elements[..i], 
            result.data().submatrix(0..i, 0..i), 
            &(0..e).map(|k| group.pow(&elements[i], ZZ.pow(p, k))).collect::<Vec<_>>()
        );
        let (k, dlog) = dlogs.into_iter().enumerate().filter_map(|(k, dlog)| dlog.map(|dlog| (k, dlog)))
            .chain([(e, (0..i).map(|_| 0).collect())].into_iter()).next().unwrap();
        *result.at_mut(i, i) = -ZZ.pow(p, k);
        for j in 0..i {
            *result.at_mut(i, j) = dlog[j];
        }
    }
    return result;
}

#[cfg(test)]
use crate::rings::zn::zn_static::Zn;

#[test]
fn test_baby_giant_step() {
    for base_bound in [21, 26, 31, 37] {
        let dlog_bound = [int_cast(base_bound, BigIntRing::RING, ZZ)];
        let G = AddGroup(ZZ);;
        assert_eq!(
            Some(vec![6]), 
            baby_giant_step(&G, 6, &[1], &dlog_bound)
        );
        assert_eq!(
            None, 
            baby_giant_step(&G, 0, &[1], &dlog_bound)
        );

        let G = AddGroup(Zn::<20>::RING);
        assert_eq!(
            Some(vec![20]), 
            baby_giant_step(&G, 0, &[1], &dlog_bound)
        );
        assert_eq!(
            Some(vec![10]), 
            baby_giant_step(&G, 10, &[1], &dlog_bound)
        );
        assert_eq!(
            Some(vec![5]), 
            baby_giant_step(&G, 0, &[16], &dlog_bound)
        );
        
        let G = ProdGroup(AddGroup(Zn::<20>::RING));
        let dlog_bound: [_; 2] = from_fn(|_| int_cast(base_bound, BigIntRing::RING, ZZ));
        assert_eq!(
            Some(vec![10, 10]), 
            baby_giant_step(&G, [10, 10], &[[1, 0], [0, 1]], &dlog_bound)
        );
        assert_eq!(
            Some(vec![8, 14]), 
            baby_giant_step(&G, [8, 10], &[[1, 2], [0, 1]], &dlog_bound)
        );
    }
    
    let G = AddGroup(ZZ);

    // the collision point is at 96
    assert_eq!(
        Some(vec![9 - 1, 6 - 1]), 
        baby_giant_step(&G, 85, &[10, 1], &from_fn::<_, 2, _>(|_| int_cast(8, BigIntRing::RING, ZZ)))
    );
    // the collision point is at 105
    assert_eq!(
        Some(vec![10 - 2, 5 - 0]), 
        baby_giant_step(&G, 85, &[10, 1], &from_fn::<_, 2, _>(|_| int_cast(21, BigIntRing::RING, ZZ)))
    );
    // the collision point is at 90
    assert_eq!(
        Some(vec![6 - 0, 30 - 5]), 
        baby_giant_step(&G, 85, &[10, 1], &from_fn::<_, 2, _>(|_| int_cast(31, BigIntRing::RING, ZZ)))
    );
}


#[test]
fn test_compute_relation_lattice_basis() {
    let G = AddGroup(Zn::<81>::RING);

    let basis = compute_relation_lattice_basis(&G, 3, 4, &[1]);
    assert_matrix_eq!(ZZ, [[-81]], basis);

    let basis = compute_relation_lattice_basis(&G, 3, 4, &[3, 6]);
    assert_matrix_eq!(ZZ, [[-27, 0], [-25, -1]], basis);

    let basis = compute_relation_lattice_basis(&G, 3, 4, &[3, 9]);
    assert_matrix_eq!(ZZ, [[-27, 0], [-24, -1]], basis);
}
use crate::field::Field;
use crate::primitive_int::StaticRing;
use crate::ring::*;
use crate::algorithms;
use crate::rings::finite::FiniteRingStore;
use crate::rings::zn::ZnRing;
use crate::wrapper::RingElementWrapper;
use crate::DEFAULT_PROBABILISTIC_REPETITIONS;

use std::hash::Hash;
use std::collections::HashMap;

const ZZ: StaticRing<i64> = StaticRing::<i64>::RING;

///
/// Computes the smallest non-negative `k, n` such that `base^(k + ni) = value` for all `i`.
/// 
/// If there is no `k < base_order_bound` that satisfies this, `None` is returned.
/// Similarly, if there is exactly one `k < base_order_bound` that satisfies this, 
/// `(k, None)` is returned.
/// 
/// The complexity of the algorithm is `O(sqrt(base_order_bound))`. In most cases, 
/// `base_order_bound` should be the order of `base` in the group.
/// 
/// Why do we need a group? Because we search for collisions `ab = ac`, and assume
/// that this implies `b = c`.
/// 
/// # Example
/// 
/// ```
/// # use feanor_math::ring::*;
/// # use feanor_math::homomorphism::*;
/// # use feanor_math::rings::zn::*;
/// # use feanor_math::rings::zn::zn_64::*;
/// # use feanor_math::wrapper::*;
/// # use feanor_math::algorithms::discrete_log::*;
/// let ring = Zn::new(17);
/// let x = RingElementWrapper::new(&ring, ring.int_hom().map(9));
/// let one = RingElementWrapper::new(&ring, ring.one());
/// assert_eq!(Some((0, Some(8))), baby_giant_step(one.clone(), &x, 1000, |a, b| a * b, one));
/// ```
/// 
#[stability::unstable(feature = "enable")]
pub fn baby_giant_step<T, F>(value: T, base: &T, base_order_bound: i64, op: F, identity: T) -> Option<(i64, Option<i64>)> 
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    let n = algorithms::int_bisect::root_floor(ZZ, ZZ.clone_el(&base_order_bound), 2) + 1;
    let mut giant_steps = HashMap::new();
    // even if the group is in general not commutative, it is here since we actually only work in the 
    // cyclic group generated by `base`
    let giant_step = pow(base, n, &op, identity.clone());
    let mut current = giant_step.clone();
    for j in 1..=n {
        _ = giant_steps.insert(current.clone(), j);
        current = op(current, &giant_step);
    }
    current = value;
    let mut result_dlog = None;
    let mut result_order = None;
    for i in 0..n {
        if let Some(j) = giant_steps.get(&current) {
            let new_dlog = j * n - i;
            if let Some(old_dlog) = result_dlog {
                let new_order = signed_gcd(result_order.unwrap_or(0), new_dlog - old_dlog, StaticRing::<i64>::RING);
                debug_assert!(new_order >= 1);
                result_order = Some(new_order);
                debug_assert_eq!(old_dlog % new_order, new_dlog % new_order);
                result_dlog = Some(old_dlog % new_order);
            } else {
                result_dlog = Some(new_dlog);
            }
        }
        current = op(current, base);
    }
    return result_dlog.map(|dlog| (dlog, result_order));
}

fn pow<T, F>(x: &T, e: i64, op: F, identity: T) -> T
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    debug_assert!(e >= 0);
    // even if the monoid is in general not commutative, it is here since we actually only work in the 
    // cyclic monoid generated by `base`
    algorithms::sqr_mul::generic_abs_square_and_multiply(x.clone(), &e, ZZ, |a| op(a.clone(), &a), |a, b| op(b, &a), identity.clone())
}

fn pohlig_hellmann_power_p<T, F>(value: T, p_e_base: &T, p: i64, e: usize, op: F, identity: T) -> Option<i64> 
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    assert!(e > 0);
    debug_assert!(algorithms::miller_rabin::is_prime(ZZ, &p, DEFAULT_PROBABILISTIC_REPETITIONS));

    let p_base = pow(p_e_base, ZZ.pow(p, e - 1), &op, identity.clone());
    debug_assert!(p_base != identity);
    debug_assert!(pow(&p_base, p, &op, identity.clone()) == identity);
    let mut fill_log = 0;
    let mut current = value;
    for i in 0..e {
        let log = baby_giant_step(pow(&current, ZZ.pow(p, e - i - 1), &op, identity.clone()), &p_base, p, &op, identity.clone())?.0;
        let p_i = ZZ.pow(p, i);
        let fill = (p - log % p) * p_i;
        current = op(current, &pow(p_e_base, fill, &op, identity.clone()));
        fill_log += fill;
    }
    return Some(ZZ.pow(p, e) - fill_log);
}

///
/// Computes the order of `x` in the group specified by `op` and `identity`.
/// 
/// It is required that `ambient_order` is a multiple of the order of `x`, e.g.
/// the order of the whole group.
/// 
#[stability::unstable(feature = "enable")]
pub fn order<T, F>(x: &T, ambient_order: i64, op: F, identity: T) -> i64
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    assert!(pow(x, ambient_order, &op, identity.clone()) == identity);
    let factorization = algorithms::int_factor::factor(&ZZ, ambient_order);
    let mut current_order = 1;
    for (p, e) in &factorization {
        let mut current = pow(x, ambient_order / ZZ.pow(*p, *e), &op, identity.clone());
        while current != identity {
            current = pow(&current, *p, &op, identity.clone());
            current_order *= p;
        }
    }
    assert!(pow(x, current_order, &op, identity.clone()) == identity);
    return current_order;
}

///
/// Computes the order of `x` in the group specified by `op` and `identity`.
/// 
/// Instead of [`order()`] this function only needs a bound on the order of `x`,
/// not a multiple of it. However, the performance is significantly worse.
/// 
/// If `x` has order greater than `order_bound`, `None` is returned.
/// 
#[stability::unstable(feature = "enable")]
pub fn order_from_bound<T, F>(x: &T, order_bound: i64, op: F, identity: T) -> Option<i64>
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    baby_giant_step(identity.clone(), x, order_bound, op, identity).unwrap().1
}

///
/// Computes the discrete logarithm of `value` w.r.t the `base` in the group specified by `op` and `identity`.
/// 
/// It is required that `order` is the order of `base` and this is finite. If the given value is
/// not contained in the subgroup generated by `base`, then `None` is returned.
/// 
/// Why do we need a group? Because we search for collisions `ab = ac`, and assume
/// that this implies `b = c`.
/// 
#[stability::unstable(feature = "enable")]
pub fn discrete_log<T, F>(value: T, base: &T, order: i64, op: F, identity: T) -> Option<i64> 
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    assert!(pow(base, order, &op, identity.clone()) == identity);
    let factorization = algorithms::int_factor::factor(&ZZ, order);
    for (p, _) in &factorization {
        assert!(pow(base, order / p, &op, identity.clone()) != identity);
    }

    let mut current_log = 1;
    let mut current_size = 1;
    for (p, e) in &factorization {
        let size = p.pow(*e as u32);
        let power = order / &size;
        let log = pohlig_hellmann_power_p(
            pow(&value, power, &op, identity.clone()), 
            &pow(&base, power, &op, identity.clone()), 
            *p,
            *e, 
            &op, 
            identity.clone()
        )?;
        current_log = algorithms::eea::inv_crt(log, current_log, &size, &current_size, ZZ);
        ZZ.mul_assign(&mut current_size, size);
    }
    return Some(current_log);
}

///
/// Computes the order of an element `x` in the multiplicative group `Fq*`
/// of a finite field `Fq`.
/// 
pub fn multiplicative_order<R: RingStore>(x: El<R>, Fq: R) -> i64
    where R::Type: ZnRing + Field + HashableElRing
{
    order(
        &RingElementWrapper::new(&Fq, x),
        Fq.size(StaticRing::<i64>::RING).unwrap() - 1,
        |a, b| a * b,
        RingElementWrapper::new(&Fq, Fq.one())
    )
}

///
/// Computes the discrete logarith of `value` w.r.t. `base` in the multiplicative
/// group `Fq*` of a finite field `Fq`.
/// 
pub fn finite_field_discrete_log<R: RingStore>(value: El<R>, base: El<R>, Fq: R) -> Option<i64>
    where R::Type: ZnRing + Field + HashableElRing
{
    discrete_log(
        RingElementWrapper::new(&Fq, value), 
        &RingElementWrapper::new(&Fq, base), 
        Fq.size(&StaticRing::<i64>::RING).unwrap() - 1, 
        |a, b| a * b, 
        RingElementWrapper::new(&Fq, Fq.one())
    )
}

#[cfg(test)]
use crate::rings::zn::zn_static::Zn;

use super::eea::signed_gcd;

#[test]
fn test_baby_giant_step() {
    assert_eq!(
        Some((6, None)), 
        baby_giant_step(6, &1, 20, |a, b| a + b, 0)
    );
    assert_eq!(
        Some((0, Some(10))), 
        baby_giant_step(0, &21, 31, |a, b| Zn::<30>::RING.add_ref_snd(a, b), 0)
    );
}

#[test]
fn test_power_p_discrete_log() {
    assert_eq!(
        Some(6), 
        pohlig_hellmann_power_p(6, &1, 3, 4, |a, b| Zn::<81>::RING.add_ref_snd(a, b), 0)
    );
}

#[test]
fn test_discrete_log() {
    assert_eq!(
        Some(78), 
        discrete_log(78, &1, 132, |a, b| Zn::<132>::RING.add_ref_snd(a, b), 0)
    );
    assert_eq!(
        Some(26),
        discrete_log(26, &1, 100, |x, y| Zn::<100>::RING.add_ref_snd(x, y), 0)
    );
}

#[test]
fn test_order() {
    assert_eq!(
        27, 
        order(&30, 81, |x, y| Zn::<81>::RING.add_ref_snd(x, y), 0)
    );
    assert_eq!(
        27 * 50, 
        order(&42, 81 * 100, |x, y| Zn::<{81 * 100}>::RING.add_ref_snd(x, y), 0)
    );
}

#[test]
fn test_order_from_bound() {
    for d in 0..5 {
        assert_eq!(
            Some(27), 
            order_from_bound(&30, 81 + d, |x, y| Zn::<81>::RING.add_ref_snd(x, y), 0)
        );
        assert_eq!(
            Some(27 * 50), 
            order_from_bound(&42, 81 * 100 + d, |x, y| Zn::<{81 * 100}>::RING.add_ref_snd(x, y), 0)
        );
    }
}
use crate::algorithms::eea::inv_crt;
use crate::algorithms::int_bisect::root_floor;
use crate::algorithms::int_factor::factor;
use crate::field::Field;
use crate::integer::int_cast;
use crate::integer::BigIntRing;
use crate::primitive_int::StaticRing;
use crate::ring::*;
use crate::algorithms;
use crate::rings::finite::FiniteRingStore;
use crate::rings::zn::ZnRing;
use crate::seq::VectorFn;
use crate::wrapper::RingElementWrapper;
use crate::DEFAULT_PROBABILISTIC_REPETITIONS;

use std::hash::Hash;
use std::collections::HashMap;
use std::mem::replace;
use std::slice::from_ref;

const ZZ: StaticRing<i64> = StaticRing::<i64>::RING;

///
/// Computes the a vector `k` with positive entries such that `generators^k = value`, 
/// assuming all elements are from an abelian group.
/// 
/// If there is no such vector with the `i`-th entry bounded by `dlog_bounds[i]`, 
/// then `None` is returned. If there are multiple vectors with entries bounded this way,
/// any one of them is returned. In the 1d-case, it is guaranteed that this is the smallest
/// one, but in the multidimensional case, no such guarantee can be made (in particular,
/// the vector in general won't be the shortest one w.r.t. any natural ordering like
/// lex or degrevlex).
/// 
/// Note: The vector `k` is required to have positive entries. In particular, this
/// function won't return the zero vector if the given element is the identity.
/// This can have unexpected consequences, like
/// ```
/// # use feanor_math::algorithms::discrete_log;
/// assert!(baby_giant_step(0, &[0], &[1000], |a, b| a + b, 0).is_none());
/// ```
/// 
/// # Implementation notes
/// 
/// The complexity of the algorithm is `O(sqrt(prod_i dlog_bounds[i]))`. 
/// Thus, when possible, `order_bound[i]` should be the order of `generators[i]`
/// in the group.
/// 
/// Why do we need a group? Because we search for collisions `ab = ac`, and assume
/// that this implies `b = c`. So actually, we only need a cancelable abelian monoid...
/// 
/// Why don't we use Pollard's rhos? Because Pollard's rho cannot deterministically
/// detect the case that `value` is not in the subgroup generated by `generators`.
/// It can do so with high probability, but only if the used hash function satisfies
/// certain properties. With BSGS, the correctness does not depend on the used hash
/// function (although performance does, of course).
/// 
/// # Example
/// 
/// ```rust
/// # use feanor_math::ring::*;
/// # use feanor_math::homomorphism::*;
/// # use feanor_math::rings::zn::*;
/// # use feanor_math::rings::zn::zn_64::*;
/// # use feanor_math::wrapper::*;
/// # use feanor_math::algorithms::discrete_log::*;
/// let ring = Zn::new(17);
/// let x = RingElementWrapper::new(&ring, ring.int_hom().map(9));
/// let one = RingElementWrapper::new(&ring, ring.one());
/// assert_eq!(Some((0, Some(8))), baby_giant_step(one.clone(), &x, 1000, |a, b| a * b, one));
/// ```
/// 
#[stability::unstable(feature = "enable")]
pub fn baby_giant_step<T, F>(value: T, generators: &[T], dlog_bounds: &[El<BigIntRing>], op: F, identity: T) -> Option<Vec<i64>> 
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    assert_eq!(generators.len(), dlog_bounds.len());
    if generators.len() == 0 {
        if value == identity {
            return Some(Vec::new());
        } else {
            return None;
        }
    }
    let ns = dlog_bounds.iter().map(|n| int_cast(root_floor(BigIntRing::RING, n.clone(), 2), ZZ, BigIntRing::RING) + 1).collect::<Vec<_>>();
    let count = int_cast(BigIntRing::RING.prod(ns.iter().map(|n| int_cast(*n, BigIntRing::RING, ZZ))), ZZ, BigIntRing::RING);
    let mut baby_step_table: HashMap<T, i64> = HashMap::with_capacity(count as usize);
    
    // fill baby step table
    {
        let mut current_els = (0..ns.len()).map(|_| value.clone()).collect::<Vec<_>>();
        let mut current_idxs = (0..ns.len()).map(|_| 0).collect::<Vec<_>>();
        for idx in 0..count {
            _ = baby_step_table.insert(current_els[ns.len() - 1].clone(), idx);

            let mut i = ns.len() - 1;
            while current_idxs[i] == ns[i] - 1 {
                if i == 0 {
                    assert!(idx + 1 == count);
                    break;
                }
                current_idxs[i] = 0;
                i -= 1;
            }
            current_idxs[i] += 1;
            current_els[i] = op(replace(&mut current_els[i], identity.clone()), &generators[i]);
            for j in (i + 1)..ns.len() {
                current_els[j] = current_els[i].clone();
            }
        }
    }

    let giant_steps = generators.iter().zip(ns.iter()).map(|(g, n)| pow(g, *n, &op, identity.clone())).collect::<Vec<_>>();
    // iterate through giant steps
    {
        let start_el = giant_steps.iter().fold(identity.clone(), &op);
        let mut current_els = (0..ns.len()).map(|_| start_el.clone()).collect::<Vec<_>>();
        let mut current_idxs = (0..ns.len()).map(|_| 1).collect::<Vec<_>>();
        for idx in 0..count {
            if let Some(bs_idx) = baby_step_table.get(&current_els[ns.len() - 1]) {
                let mut bs_idx = *bs_idx;
                for j in (0..ns.len()).rev() {
                    let bs_idxs_j = bs_idx % ns[j];
                    bs_idx = bs_idx / ns[j];
                    current_idxs[j] = current_idxs[j] * ns[j] - bs_idxs_j;
                }
                return Some(current_idxs);
            }

            let mut i = ns.len() - 1;
            while current_idxs[i] == ns[i] {
                if i == 0 {
                    assert!(idx + 1 == count);
                    break;
                }
                current_idxs[i] = 1;
                i -= 1;
            }
            current_idxs[i] += 1;
            current_els[i] = op(replace(&mut current_els[i], identity.clone()), &giant_steps[i]);
            for j in (i + 1)..ns.len() {
                current_els[j] = current_els[i].clone();
            }
        }
    }

    return None;
}

fn pow<T, F>(x: &T, e: i64, op: F, identity: T) -> T
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    debug_assert!(e >= 0);
    // even if the monoid is in general not commutative, it is here since we actually only work in the 
    // cyclic monoid generated by `base`
    algorithms::sqr_mul::generic_abs_square_and_multiply(x.clone(), &e, ZZ, |a| op(a.clone(), &a), |a, b| op(b, &a), identity.clone())
}

fn pohlig_hellmann_power_p<T, F>(value: T, generators_p_e: &[T], p: i64, e: usize, op: F, identity: T) -> Option<Vec<i64>> 
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    assert!(e > 0);
    debug_assert!(algorithms::miller_rabin::is_prime(ZZ, &p, DEFAULT_PROBABILISTIC_REPETITIONS));
    let dlog_bounds = (0..generators_p_e.len()).map(|_| int_cast(p, BigIntRing::RING, ZZ)).collect::<Vec<_>>();

    let gen_order_logp = |g: &T| {
        let mut current = g.clone();
        if current == identity {
            return (current, 0);
        }
        for i in 0..e {
            let next = pow(&current, p, &op, identity.clone());
            if next == identity {
                return (current, i + 1);
            } else {
                current = next;
            }
        }
        unreachable!("generator^(p^e) should be the identity");
    };
    let generators_p = generators_p_e.iter().map(|g| gen_order_logp(g)).collect::<Vec<_>>();
    debug_assert!(generators_p.iter().all(|(g, _)| pow(g, p, &op, identity.clone()) == identity));

    let mut fill_log = (0..generators_p.len()).map(|_| 0).collect::<Vec<_>>();
    let mut current = value;
    for i in 0..e {
        let mut used_gen_indices = Vec::new();
        let mut used_gens = Vec::new();
        for j in 0..generators_p.len() {
            if generators_p[j].1 + i >= e {
                used_gen_indices.push(j);
                used_gens.push(generators_p[j].0.clone());
            }
        }

        let log = baby_giant_step(
            pow(&current, ZZ.pow(p, e - i - 1), &op, identity.clone()), 
            &used_gens, 
            &dlog_bounds[..used_gens.len()], 
            &op, 
            identity.clone()
        )?;
        let fill = (0..log.len()).map_fn(|j|
            (p - log[j] % p) * ZZ.pow(p, i + generators_p[used_gen_indices[j]].1 - e)
        );
        current = op(current, &(0..fill.len()).fold(identity.clone(), |x, j| op(x, &pow(&generators_p_e[used_gen_indices[j]], fill.at(j), &op, identity.clone()))));
        for j in 0..fill.len() {
            fill_log[used_gen_indices[j]] += fill.at(j);
        }
    }
    return Some(fill_log.into_iter().map(|f| ZZ.pow(p, e) - f).collect());
}

///
/// Computes the order of `x` in the group specified by `op` and `identity`.
/// 
/// It is required that `ambient_order` is a multiple of the order of `x`, e.g.
/// the order of the whole group.
/// 
#[stability::unstable(feature = "enable")]
pub fn order<T, F>(x: &T, ambient_order: i64, op: F, identity: T) -> i64
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    assert!(pow(x, ambient_order, &op, identity.clone()) == identity);
    let factorization = algorithms::int_factor::factor(&ZZ, ambient_order);
    let mut current_order = 1;
    for (p, e) in &factorization {
        let mut current = pow(x, ambient_order / ZZ.pow(*p, *e), &op, identity.clone());
        while current != identity {
            current = pow(&current, *p, &op, identity.clone());
            current_order *= p;
        }
    }
    assert!(pow(x, current_order, &op, identity.clone()) == identity);
    return current_order;
}

///
/// Computes the order of `x` in the group specified by `op` and `identity`.
/// 
/// Instead of [`order()`] this function only needs a bound on the order of `x`,
/// not a multiple of it. However, the performance is significantly worse.
/// 
/// If `x` has order greater than `order_bound`, `None` is returned.
/// 
#[stability::unstable(feature = "enable")]
pub fn order_from_bound<T, F>(x: &T, order_bound: &El<BigIntRing>, op: F, identity: T) -> Option<i64>
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    baby_giant_step(identity.clone(), from_ref(x), from_ref(order_bound), op, identity).map(|mut k| k.pop().unwrap())
}

///
/// Computes the discrete logarithm of `value` w.r.t the `generators` in the
/// group specified by `op` and `identity`.
/// 
/// It is required that `order` is a multiple of the order of every generator in `generators`,
/// and this is finite. If the given value is not contained in the subgroup generated
/// by `base`, then `None` is returned.
/// 
/// Why do we need a group? Because we search for collisions `ab = ac`, and assume
/// that this implies `b = c`. So actually, we only need a cancelable abelian monoid...
/// 
#[stability::unstable(feature = "enable")]
pub fn discrete_log<T, F>(value: T, generators: &[T], order: i64, op: F, identity: T) -> Option<Vec<i64>> 
    where F: Fn(T, &T) -> T, T: Clone + Hash + Eq
{
    assert!(generators.iter().all(|g| pow(g, order, &op, identity.clone()) == identity));
    let factorization = factor(&ZZ, order);

    let mut current_log = (0..generators.len()).map(|_| 1).collect::<Vec<_>>();
    let mut current_size = 1;
    for (p, e) in &factorization {
        let size = p.pow(*e as u32);
        let power = order / &size;
        let log = pohlig_hellmann_power_p(
            pow(&value, power, &op, identity.clone()), 
            &generators.iter().map(|g| pow(g, power, &op, identity.clone())).collect::<Vec<_>>(), 
            *p,
            *e, 
            &op, 
            identity.clone()
        )?;
        for j in 0..generators.len() {
            current_log[j] = inv_crt(log[j], current_log[j], &size, &current_size, ZZ);
        }
        ZZ.mul_assign(&mut current_size, size);
    }
    return Some(current_log);
}

///
/// Computes the order of an element `x` in the multiplicative group `Fq*`
/// of a finite field `Fq`.
/// 
pub fn multiplicative_order<R: RingStore>(x: El<R>, Fq: R) -> i64
    where R::Type: ZnRing + Field + HashableElRing
{
    order(
        &RingElementWrapper::new(&Fq, x),
        Fq.size(StaticRing::<i64>::RING).unwrap() - 1,
        |a, b| a * b,
        RingElementWrapper::new(&Fq, Fq.one())
    )
}

///
/// Computes the discrete logarith of `value` w.r.t. `base` in the multiplicative
/// group `Fq*` of a finite field `Fq`.
/// 
pub fn finite_field_discrete_log<R: RingStore>(value: El<R>, base: El<R>, Fq: R) -> Option<i64>
    where R::Type: ZnRing + Field + HashableElRing
{
    discrete_log(
        RingElementWrapper::new(&Fq, value), 
        &[RingElementWrapper::new(&Fq, base)], 
        Fq.size(&StaticRing::<i64>::RING).unwrap() - 1, 
        |a, b| a * b, 
        RingElementWrapper::new(&Fq, Fq.one())
    ).map(|dlogs| dlogs.into_iter().next().unwrap())
}

#[cfg(test)]
use crate::rings::zn::zn_static::Zn;
#[cfg(test)]
use std::array::from_fn;

#[test]
fn test_baby_giant_step() {
    for base_bound in [21, 26, 31, 37] {
        let dlog_bound = [int_cast(base_bound, BigIntRing::RING, ZZ)];
        let Z20 = Zn::<20>::RING;
        assert_eq!(
            Some(vec![6]), 
            baby_giant_step(6, &[1], &dlog_bound, |a, b| a + b, 0)
        );
        assert_eq!(
            None, 
            baby_giant_step(0, &[1], &dlog_bound, |a, b| a + b, 0)
        );
        assert_eq!(
            Some(vec![20]), 
            baby_giant_step(0, &[1], &dlog_bound, |a, b| Z20.add_ref_snd(a, b), 0)
        );
        assert_eq!(
            Some(vec![10]), 
            baby_giant_step(10, &[1], &dlog_bound, |a, b| Z20.add_ref_snd(a, b), 0)
        );
        assert_eq!(
            Some(vec![5]), 
            baby_giant_step(0, &[16], &dlog_bound, |a, b| Z20.add_ref_snd(a, b), 0)
        );
        
        let dlog_bound: [_; 2] = from_fn(|_| int_cast(base_bound, BigIntRing::RING, ZZ));
        assert_eq!(
            Some(vec![10, 10]), 
            baby_giant_step([10, 10], &[[1, 0], [0, 1]], &dlog_bound, |a, b| from_fn(|i| Z20.add(a[i], b[i])), [0, 0])
        );
        assert_eq!(
            Some(vec![8, 14]), 
            baby_giant_step([8, 10], &[[1, 2], [0, 1]], &dlog_bound, |a, b| from_fn(|i| Z20.add(a[i], b[i])), [0, 0])
        );
    }
    
    // the collision point is at 96
    assert_eq!(
        Some(vec![9 - 1, 6 - 1]), 
        baby_giant_step(85, &[10, 1], &from_fn::<_, 2, _>(|_| int_cast(8, BigIntRing::RING, ZZ)), |a, b| a + b, 0)
    );
    // the collision point is at 105
    assert_eq!(
        Some(vec![10 - 2, 5 - 0]), 
        baby_giant_step(85, &[10, 1], &from_fn::<_, 2, _>(|_| int_cast(21, BigIntRing::RING, ZZ)), |a, b| a + b, 0)
    );
    // the collision point is at 90
    assert_eq!(
        Some(vec![6 - 0, 30 - 5]), 
        baby_giant_step(85, &[10, 1], &from_fn::<_, 2, _>(|_| int_cast(31, BigIntRing::RING, ZZ)), |a, b| a + b, 0)
    );
}

#[test]
fn test_power_p_discrete_log() {
    let Z81 = Zn::<81>::RING;
    assert_eq!(
        Some(vec![6]), 
        pohlig_hellmann_power_p(6, &[1], 3, 4, |a, b| Z81.add_ref_snd(a, b), 0)
    );
    assert_eq!(
        2, 
        pohlig_hellmann_power_p(6, &[3], 3, 4, |a, b| Z81.add_ref_snd(a, b), 0).unwrap().pop().unwrap() % 27
    );
    assert_eq!(
        Some(vec![5, 37]), 
        pohlig_hellmann_power_p([5, 37], &[[1, 0], [0, 1]], 3, 4, |a, b| from_fn(|i| Z81.add(a[i], b[i])), [0, 0])
    );
    assert_eq!(
        None, 
        pohlig_hellmann_power_p([5, 12], &[[1, 0], [0, 9]], 3, 4, |a, b| from_fn(|i| Z81.add(a[i], b[i])), [0, 0])
    );
    let [x, y] = pohlig_hellmann_power_p([5, 18], &[[1, 0], [0, 9]], 3, 4, |a, b| from_fn(|i| Z81.add(a[i], b[i])), [0, 0]).unwrap().try_into().unwrap();
    assert_eq!(5, x);
    assert_eq!(2, y % 9);

    let Z100 = Zn::<100>::RING;
    let [x, y] = pohlig_hellmann_power_p(36, &[40, 16], 5, 2, |a, b| Z100.add_ref_snd(a, b), 0).unwrap().try_into().unwrap();
    assert_eq!(36, (x * 40 + y * 16) % 100);
}

#[test]
fn test_discrete_log() {
    let Z132 = Zn::<132>::RING;
    assert_eq!(
        Some(vec![78]), 
        discrete_log(78, &[1], 132, |a, b| Z132.add_ref_snd(a, b), 0)
    );
    let Z100 = Zn::<100>::RING;
    assert_eq!(
        Some(vec![26]),
        discrete_log(26, &[1], 100, |x, y| Z100.add_ref_snd(x, y), 0)
    );
    assert_eq!(
        Some(vec![75, 16]),
        discrete_log([7, 5], &[[1, 3], [2, 5]], 100, |x, y| from_fn(|i| Z100.add(x[i], y[i])), [0, 0])
    );
    let [x, y] = discrete_log(34, &[10, 4], 100, |x, y| Z100.add_ref_snd(x, y), 0).unwrap().try_into().unwrap();
    assert_eq!(34, (x * 10 + y * 4) % 100);

    assert_eq!(
        None,
        discrete_log(33, &[10, 4], 100, |x, y| Z100.add_ref_snd(x, y), 0)
    );
}

#[test]
fn test_order() {
    assert_eq!(
        27, 
        order(&30, 81, |x, y| Zn::<81>::RING.add_ref_snd(x, y), 0)
    );
    assert_eq!(
        27 * 50, 
        order(&42, 81 * 100, |x, y| Zn::<{81 * 100}>::RING.add_ref_snd(x, y), 0)
    );
}

#[test]
fn test_order_from_bound() {
    for d in 0..5 {
        assert_eq!(
            Some(27), 
            order_from_bound(&30, &int_cast(81 + d, BigIntRing::RING, ZZ), |x, y| Zn::<81>::RING.add_ref_snd(x, y), 0)
        );
        assert_eq!(
            Some(27 * 50), 
            order_from_bound(&42, &int_cast(81 * 100 + d, BigIntRing::RING, ZZ), |x, y| Zn::<{81 * 100}>::RING.add_ref_snd(x, y), 0)
        );
    }
}
use crate::divisibility::Domain;
use crate::ring::*;
use crate::pid::*;

///
/// Trait for rings that are fields, i.e. where every
/// nonzero element has an inverse.
/// 
/// Note that fields must be commutative.
/// 
pub trait Field: Domain + EuclideanRing {

    fn div(&self, lhs: &Self::Element, rhs: &Self::Element) -> Self::Element {
        assert!(!self.is_zero(rhs));
        assert!(self.is_commutative());
        return self.checked_left_div(lhs, rhs).unwrap();
    }
}

///
/// Trait for [`RingStore`]s that store [`Field`]s. Mainly used
/// to provide a convenient interface to the `Field`-functions.
/// 
pub trait FieldStore: RingStore + EuclideanRingStore
    where Self::Type: Field
{
    delegate!{ Field, fn div(&self, lhs: &El<Self>, rhs: &El<Self>) -> El<Self> }
}

impl<R> FieldStore for R
    where R: RingStore, R::Type: Field
{}

///
/// Field such that every finite degree extension field is separable.
/// 
/// This is equivalent to the following:
///  - Every irreducible polynomial is square-free (over the algebraic closure)
///  - Every finite-degree field extension is simple, i.e. generated by a single element
/// 
pub trait PerfectField: Field {}

#[cfg(any(test, feature = "generic_tests"))]
pub mod generic_tests {
    use super::*;

    pub fn test_field_axioms<R, I>(R: R, edge_case_elements: I)
        where R: FieldStore, R::Type: Field, I: Iterator<Item = El<R>>
    {
        let edge_case_elements = edge_case_elements.collect::<Vec<_>>();
        for (i, a) in edge_case_elements.iter().enumerate() {
            for (j, b) in edge_case_elements.iter().enumerate() {
                assert!(i == j || !R.eq_el(&a, &b));
                if !R.is_zero(&b) {
                    assert_el_eq!(R, a, R.mul_ref_fst(&b, R.div(&a, &b)));
                }
            }
        }
    }
}